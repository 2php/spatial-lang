
.. role:: black
.. role:: gray
.. role:: silver
.. role:: white
.. role:: maroon
.. role:: red
.. role:: fuchsia
.. role:: pink
.. role:: orange
.. role:: yellow
.. role:: lime
.. role:: green
.. role:: olive
.. role:: teal
.. role:: cyan
.. role:: aqua
.. role:: blue
.. role:: navy
.. role:: purple

.. _Stream:

Stream
======

<auto-generated stub>

Static methods
--------------

.. parsed-literal::

  :maroon:`def` apply(cchain: :doc:`counterchain`)(func: (:doc:`indices`) => Unit): Unit

Shorthand form for foreach. Creates a pipelined, parallelizable state machine which iterates through the ND domain defined by the supplied counterchain, executing the specified function every iteration. If the function contains other state machines, this is executed as an outer loop with each inner state machine run as a stage in a streaming fashion.  Note that this is the general form for N-dimensional domains. Use the specialized 1, 2, or 3D forms when possible. 

	* **cchain** \- counterchain determining index domain
	* **func** \- the function to be executed each iteration

*********

.. parsed-literal::

  :maroon:`def` apply(c0: :doc:`counter`)(func: (:doc:`Index <fixpt>`) => Unit): Unit

Shorthand form for foreach. Creates a pipelined, parallelizable state machine which iterates through the 1D domain defined by the supplied counter, executing the specified function every iteration. If the function contains other state machines, this is executed as an outer as an outer loop with each inner state machine run as a stage in a streaming fashion. 

	* **c0** \- counter specifying 1D index domain
	* **func** \- the function to be executed each iteration

*********

.. parsed-literal::

  :maroon:`def` apply(c0: :doc:`counter`, c1: :doc:`counter`)(func: (:doc:`Index <fixpt>`, :doc:`Index <fixpt>`) => Unit): Unit

Shorthand form for foreach. Creates a pipelined, parallelizable state machine which iterates through the 2D domain defined by the supplied counter, executing the specified function every iteration. If the function contains other state machines, this is executed as an outer as an outer loop with each inner state machine run as a stage in a streaming fashion. 

	* **c0** \- counter for first dimension
	* **c1** \- counter for second dimension
	* **func** \- the function to be executed each iteration

*********

.. parsed-literal::

  :maroon:`def` apply(c0: :doc:`counter`, c1: :doc:`counter`, c2: :doc:`counter`)(func: (:doc:`Index <fixpt>`, :doc:`Index <fixpt>`, :doc:`Index <fixpt>`) => Unit): Unit

Shorthand form for foreach. Creates a pipelined, parallelizable state machine which iterates through the 3D domain defined by the supplied counter, executing the specified function every iteration. If the function contains other state machines, this is executed as an outer as an outer loop with each inner state machine run as a stage in a streaming fashion. 

	* **c0** \- counter for first dimension
	* **c1** \- counter for second dimension
	* **c2** \- counter for third dimension
	* **func** \- the function to be executed each iteration

*********

.. parsed-literal::

  :maroon:`def` apply(body:  => Unit): Unit

Creates a "unit" pipeline. Used as a wrapper node around simple logic in the body. 


*********

.. parsed-literal::

  :maroon:`def` fold(cchain: :doc:`counterchain`, accum: Int)(map: C\[T\])(reduce: (:doc:`indices`) => C\[T\])(w: (T, T) => T)(:maroon:`implicit` ev0: Mem[T,C],ev1: Num[T],ev2: Manifest[C\[T\]]): C\[T\]

Multi-dimensional fused map-reduce of memories. Creates a state machine which iterates over the supplied multi-dimensional domain, reducing the collection resulting from each iteration of the map using the supplied associative scalar reduction function. This state machine is always run as an outer loop of state machines. If the memory result of the map function has multiple elements (e.g. SRAMs), the reduction is run as an inner loop where the supplied associative reduction is used on each iteration. Supported memory types are: Regs and SRAMs. 

	* **cchain** \- counterchain specifying the index domain
	* **accum** \- accumulator for holding intermediate reduction values
	* **map** \- map function
	* **reduce** \- associative reduction function
	* **returns** the accumulator used in this reduction (identical to *accum*)

*********

.. parsed-literal::

  :maroon:`def` fold(c0: :doc:`counter`)(accum: C\[T\])(map: (:doc:`Index <fixpt>`) => C\[T\])(reduce: (T, T) => T)(:maroon:`implicit` ev0: Mem[T,C],ev1: Num[T],ev2: Manifest[C\[T\]]): C\[T\]

1-dimensional fused map-reduce of memories. Creates a state machine which iterates over the supplied 1D domain, reducing the collection resulting from each iteration of the map using the supplied associative scalar reduction function. This state machine is always run as an outer loop of state machines. If the memory result of the map function has multiple elements (e.g. SRAMs), the reduction is run as an inner loop where the supplied associative reduction is used on each iteration. Supported memory types are: Regs and SRAMs. 

	* **c0** \- counter specifying the 1D index domain
	* **accum** \- accumulator for holding intermediate reduction values
	* **map** \- map function
	* **reduce** \- associative reduction function
	* **returns** the accumulator used in this reduction (identical to *accum*)

*********

.. parsed-literal::

  :maroon:`def` fold(c0: :doc:`counter`, c1: :doc:`counter`)(accum: C\[T\])(map: (:doc:`Index <fixpt>`, :doc:`Index <fixpt>`) => C\[T\])(reduce: (T, T) => T)(:maroon:`implicit` ev0: Mem[T,C],ev1: Num[T],ev2: Manifest[C\[T\]]): C\[T\]

2-dimensional fused map-reduce of memories. Creates a state machine which iterates over the supplied 2D domain, reducing the collection resulting from each iteration of the map using the supplied associative scalar reduction function. This state machine is always run as an outer loop of state machines. If the memory result of the map function has multiple elements (e.g. SRAMs), the reduction is run as an inner loop where the supplied associative reduction is used on each iteration. Supported memory types are: Regs and SRAMs. 

	* **c0** \- counter for the first dimension
	* **c1** \- counter for the second dimension
	* **accum** \- accumulator for holding intermediate reduction values
	* **map** \- map function
	* **reduce** \- associative reduction function
	* **returns** the accumulator used in this reduction (identical to *accum*)

*********

.. parsed-literal::

  :maroon:`def` fold(c0: :doc:`counter`, c1: :doc:`counter`, c2: :doc:`counter`)(accum: C\[T\])(map: (:doc:`Index <fixpt>`, :doc:`Index <fixpt>`, :doc:`Index <fixpt>`) => C\[T\])(reduce: (T, T) => T)(:maroon:`implicit` ev0: Mem[T,C],ev1: Num[T],ev2: Manifest[C\[T\]]): C\[T\]

3-dimensional fused map-reduce of memories. Creates a state machine which iterates over the supplied 3D domain, reducing the collection resulting from each iteration of the map using the supplied associative scalar reduction function. This state machine is always run as an outer loop of state machines. If the memory result of the map function has multiple elements (e.g. SRAMs), the reduction is run as an inner loop where the supplied associative reduction is used on each iteration. Supported memory types are: Regs and SRAMs. 

	* **c0** \- counter for the first dimension
	* **c1** \- counter for the second dimension
	* **c2** \- counter for the third dimension
	* **accum** \- accumulator for holding intermediate reduction values
	* **map** \- map function
	* **reduce** \- associative reduction function
	* **returns** the accumulator used in this reduction (identical to *accum*)

*********

.. parsed-literal::

  :maroon:`def` foreach(cchain: :doc:`counterchain`)(func: (:doc:`indices`) => Unit): Unit

Creates a pipelined, parallelizable state machine which iterates through the ND domain defined by the supplied counterchain, executing the specified function every iteration. If the function contains other state machines, this is executed as an outer loop with each inner state machine run as a stage in a streaming fashion. Note that this is the general form for N-dimensional domains. Use the specialized 1, 2, or 3D forms when possible. 

	* **cchain** \- counterchain determining index domain
	* **func** \- the function to be executed each iteration

*********

.. parsed-literal::

  :maroon:`def` foreach(c0: :doc:`counter`)(func: (:doc:`Index <fixpt>`) => Unit): Unit

Creates a pipelined, parallelizable state machine which iterates through the 1D domain defined by the supplied counter, executing the specified function every iteration. If the function contains other state machines, this is executed as an outer as an outer loop with each inner state machine run as a stage in a streaming fashion. 

	* **c0** \- counter specifying 1D index domain
	* **func** \- the function to be executed each iteration

*********

.. parsed-literal::

  :maroon:`def` foreach(c0: :doc:`counter`, c1: :doc:`counter`)(func: (:doc:`Index <fixpt>`, :doc:`Index <fixpt>`) => Unit): Unit

Creates a pipelined, parallelizable state machine which iterates through the 1D domain defined by the supplied counter, executing the specified function every iteration. If the function contains other state machines, this is executed as an outer as an outer loop with each inner state machine run as a stage in a streaming fashion. 

	* **c0** \- counter for first dimension
	* **c1** \- counter for second dimension
	* **func** \- the function to be executed each iteration

*********

.. parsed-literal::

  :maroon:`def` foreach(c0: :doc:`counter`, c1: :doc:`counter`, c2: :doc:`counter`)(func: (:doc:`Index <fixpt>`, :doc:`Index <fixpt>`, :doc:`Index <fixpt>`) => Unit): Unit

Creates a pipelined, parallelizable state machine which iterates through the 3D domain defined by the supplied counter, executing the specified function every iteration. If the function contains other state machines, this is executed as an outer as an outer loop with each inner state machine run as a stage in a streaming fashion. 

	* **c0** \- counter for first dimension
	* **c1** \- counter for second dimension
	* **c2** \- counter for third dimension
	* **func** \- the function to be executed each iteration

*********

.. parsed-literal::

  :maroon:`def` reduce(cchain: :doc:`counterchain`)(zero: T)(map: (:doc:`indices`) => T)(reduce: (T, T) => T)(:maroon:`implicit` ev0: Num[T]): :doc:`reg`\[T\]

Multi-dimensional scalar fused map-reduce. Creates a state machine which iterates over the given multi-dimensional domain, reducing the scalar result of each iteration of the map using the supplied associative reduction function. If the map function contains other state machines, this is executed as an outer loop with each inner state machine run as a stage in a streaming fashion. Note that this is the general form for N-dimensional domains. Use the specialized 1, 2, or 3D forms when possible. 

	* **cchain** \- counterchain determining index domain
	* **zero** \- identity value for this reduction function
	* **map** \- scalar map function
	* **reduce** \- associative reduction function
	* **returns** a register containing the result of this reduction

*********

.. parsed-literal::

  :maroon:`def` reduce(c0: :doc:`counter`)(zero: T)(map: (:doc:`Index <fixpt>`) => T)(reduce: (T, T) => T)(:maroon:`implicit` ev0: Num[T]): :doc:`reg`\[T\]

1-dimensional scalar fused map-reduce. Creates a state machine which iterates over the supplied 1D domain, reducing the scalar result of each iteration of the map using the supplied associative reduction function. If the map function contains other state machines, this is executed as an outer loop with each inner state machine run as a stage in a streaming fashion. 

	* **c0** \- counter specifying the 1D index domain
	* **zero** \- identity value for this reduction function
	* **map** \- scalar map function
	* **reduce** \- associative reduction function
	* **returns** a register containing the result of this reduction

*********

.. parsed-literal::

  :maroon:`def` reduce(c0: :doc:`counter`, c1: :doc:`counter`)(zero: T)(map: (:doc:`Index <fixpt>`, :doc:`Index <fixpt>`) => T)(reduce: (T, T) => T)(:maroon:`implicit` ev0: Num[T]): :doc:`reg`\[T\]

2-dimensional scalar fused map-reduce. Creates a state machine which iterates over the supplied 2D domain, reducing the scalar result of each iteration of the map using the supplied associative reduction function. If the map function contains other state machines, this is executed as an outer loop with each inner state machine run as a stage in a streaming fashion. 

	* **c0** \- counter for the first dimension
	* **c1** \- counter for the second dimension
	* **zero** \- identity value for this reduction function
	* **map** \- scalar map function
	* **reduce** \- associative reduction function
	* **returns** the accumulator used in this reduction (identical to *accum*)

*********

.. parsed-literal::

  :maroon:`def` reduce(c0: :doc:`counter`, c1: :doc:`counter`, c2: :doc:`counter`)(zero: T)(map: (:doc:`Index <fixpt>`, :doc:`Index <fixpt>`, :doc:`Index <fixpt>`) => T)(reduce: (T, T) => T)(:maroon:`implicit` ev0: Num[T]): :doc:`reg`\[T\]

3-dimensional scalar fused map-reduce. Creates a state machine which iterates over the supplied 3D domain, reducing the scalar result of each iteration of the map using the supplied associative reduction function. If the map function contains other state machines, this is executed as an outer loop with each inner state machine run as a stage in a streaming fashion. 

	* **c0** \- counter for the first dimension
	* **c1** \- counter for the second dimension
	* **c2** \- counter for the third dimension
	* **zero** \- identity value for this reduction function
	* **map** \- scalar map function
	* **reduce** \- associative reduction function
	* **returns** a register containing the result of this reduction

